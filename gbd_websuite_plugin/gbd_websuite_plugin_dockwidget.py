# -*- coding: utf-8 -*-
"""
/***************************************************************************
 gbdWebsuiteDockWidget
                                 A QGIS plugin
 Plugin zur einfachen Bereitstellung eines GBD Websuite Projektes.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-04-27
        git sha              : $Format:%H$
        copyright            : (C) 2020 by GBD
        email                : info@gbd-consult.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

###
# standard library imports
###
import os
import shutil
import tempfile
import xml.etree.ElementTree as ET
import json
import webbrowser
import time
import requests as r
import pathlib

#test
#import threading

###
# third party imports
###

# cartographic projections and coordinate transformations library
import pyproj

# python bindings for QT application Framework
from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, QFileInfo, QThread, Qt

# Python QGIS API
from qgis.utils import iface
import qgis.core

###
# local imports
###
from .gws_api import gws_api_call, as_uid
from .gws_password import encode
from .gbd_hash import gbd_manager_hash
#from gbd_modules import gws_api, gws_password

from .dw_b_options import button_options

#pb
#from .gbd_websuite_progressBar import progressBar

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'gbd_websuite_plugin_dockwidget_base.ui'))


class gbdWebsuiteDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()
    #pb
    # countChanged = pyqtSignal(int)

    def __init__(self, parent=None):
        """Constructor."""
        super(gbdWebsuiteDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.iface = iface

        #hash
        self.H = gbd_manager_hash()
        #pb
        # self.pB = progressBar()

        #self.uLE = uploadLayersExternal()

        # set path to a directory where projects are stores
        # later that has to work automated
        # variables that should come from
        self.config = None

        # variables
        self.confPath = None
        self.hostname = None
        self.username = None
        self.password = None
        self.auth = None
        self.proj = None
        self.authToken = None
        self.projekt = None
        self.title = None
        self.rowPosition = None
        self.path = None
        self.row = None
        self.font = None
        self.projectFolder = None

        # connect functions to buttons
        self.button_save.clicked.connect(self.button_add_Project)
        self.button_delete_proj.clicked.connect(self.delete_Project)
        self.button_load_proj.clicked.connect(self.load_Project)
        self.button_load_proj.clicked.connect(self.open_Project)
        self.button_help.clicked.connect(self.open_Help)
        self.button_options.clicked.connect(self.doButtonOptions)

        # connect functions to signals
        qgis.core.QgsProject.instance().readProject.connect(self.project_Title_or_File)
        qgis.core.QgsProject.instance().writeProject.connect(self.project_Title_or_File)
        self.iface.newProjectCreated.connect(self.new_Project)
        self.table_proj.itemSelectionChanged.connect(self.get_row)
        #pb
        #self.uLE.countChanged.connect(self.onCountChanged)
        #self.countChanged.connect(self.setPB)

    #pb
    #def setPB(self, value):
        #self.pB.progressBar.setValue(value)

    '''def showProgressBar(self):
        self.pB = progressBar()
        self.pB.show()
        self.calc = External()
        self.calc.countChanged.connect(self.onCountChanged)
        self.calc.start()

    def onCountChanged(self, value):
        self.pB.progressBar.setValue(value)'''

    '''def sleeper(self, seconds):
        print('start')
        time.sleep(seconds)
        print('fertig')

    def showProgressBar(self):

        self.pB = progressBar()
        self.pB.show()
        self.pB.progressBar.setValue(1)
        t = threading.Thread(target = self.sleeper, args=(2,))
        t.start()
        t.join()
        self.pB.progressBar.setValue(10)'''


        
    def doButtonOptions(self):

        ''' TODO: Function to open the advanced options main window, must be implemented '''

        button_options()

    def changedConfig(self):

        self.clear_Plugin()
        self.checkAuth()

    def checkAuthLocal(self):

        '''
        Function to check for local saved login data.
        '''

        self.confPath = qgis.core.QgsApplication.qgisSettingsDirPath()
        if os.path.exists(os.path.join(self.confPath, 'GBD_WebSuite')):
            for file in os.listdir(os.path.join(self.confPath, 'GBD_WebSuite')):
                if file == 'qgws-manager.json':
                    self.config_file.setDocumentPath(os.path.join(self.confPath, 'GBD_WebSuite', file))
                    self.checkAuth()
        self.config_file.valueChanged.connect(self.changedConfig)
        '''
                    self.config_file.valueChanged.connect(self.changedConfig)
                else:
                    self.config_file.valueChanged.connect(self.changedConfig)
            else:
                self.config_file.valueChanged.connect(self.changedConfig)
        else:
            self.config_file.valueChanged.connect(self.changedConfig)
        '''

    def checkAuth(self):

        '''
        Function to start the Plugin.
        Controlls if the config.json File is valid.
        If the file is valid, the Plugin is enabled and existing projects are loaded from the server.
        '''

        f = self.iface.settingsMenu().font().toString().rsplit(",")[0]
        s = int(self.iface.settingsMenu().font().toString().rsplit(",")[1])
        self.font = QtGui.QFont(f, s)

        self.config = self.config_file.documentPath()
        if self.config:
            try:
                with open(self.config, 'r') as conf_file:
                    data = json.load(conf_file)
                    try:
                        for p in data:
                            self.username = p['user']
                            self.password = p['password']
                            self.hostname = p['hostname']
                            if 'projectFolder' in p:
                                self.projectFolder = p['projectFolder']
                            else:
                                self.projectFolder = os.path.join(self.confPath, 'GBD_WebSuite', 'projects')

                            self.auth = (self.username, self.password)
                            try:
                                self.proj = gws_api_call(
                                    self.hostname,
                                    'fsList',
                                    {},
                                    auth=self.auth
                                )

                                if list(self.proj.keys())[0] != 'entries':
                                    iface.messageBar().pushCritical(self.tr('Authentifizierung fehlgeschlagen'),
                                                                    self.tr('Falsche Logindaten!'))

                                else:
                                    self.iface.messageBar().pushSuccess(self.tr('Login erfolgreich'),
                                                                        self.tr('Sie sind jetzt als "')
                                                                        + self.username
                                                                        + self.tr(' auf dem Server: ')
                                                                        + self.hostname
                                                                        + self.tr('" angemeldet.'))

                            except r.exceptions.SSLError:
                                self.clear_Plugin()
                                iface.messageBar().pushCritical(self.tr('GWS Fehler!'),
                                                                self.tr('Das SSL-Zertifikat des Servers ist abgelaufen. Bitte kontaktieren Sie den Administrator.'))
                                

                            except:
                                iface.messageBar().pushCritical(self.tr('GWS Fehler!'),
                                                                self.tr('Konnte keine Verbindung zum Server herstellen.'))
                                self.clear_Plugin()

                            else:

                                data = []

                                for value in self.proj.values():
                                    for i in value:
                                        for projects in i.values():
                                            if projects.endswith('.config.cx'):
                                                temp_l = []
                                                temp_l.append(projects[:-10])
                                                temp_l.append(str(projects[:-10]))
                                                data.append(temp_l)

                                            else:
                                                pass

                                nb_row = len(data)
                                nb_col = 2

                                self.table_proj.setRowCount(nb_row)
                                self.table_proj.setColumnCount(nb_col)

                                for row in range(nb_row):
                                    for col in range(nb_col):
                                        item = QtWidgets.QTableWidgetItem(str(data[row][col]))
                                        self.table_proj.setItem(row, 0, item)
                                        self.table_proj.setCellWidget(row, 1, EditButtonWidget(row, item.text(), self.hostname, self.font))
                                    
                                self.table_proj.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
                                self.table_proj.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
                                self.label_5.setText(self.tr("Angemeldet als: ") + self.username)
                                self.authToken = True
                                
                                if self.authToken:
                                    self.aktuelles_projekt.setEnabled(True)
                                    self.liste_projekte.setEnabled(True)
                                    self.table_proj.setEnabled(True)
                                    self.project_Title_or_File()

                    except: 
                        self.iface.messageBar().pushCritical(self.tr('Login fehlgeschlagen'),
                                                            self.tr('Ihre Conig-Datei enthält nicht die benötigten Informationen oder ist beschädigt!'))
                        self.clear_Plugin()

            except:
                self.iface.messageBar().pushCritical(self.tr('Login fehlgeschlagen'),
                                                    self.tr('Bitte eine .json Datei auswählen!'))
                self.clear_Plugin()

        else:
            self.clear_Plugin()

    def project_Title_or_File(self):

        '''Fills data_projekt with the current project title (if not present use project file name)'''

        if self.authToken:
            project = qgis.core.QgsProject.instance().baseName()
            self.title = qgis.core.QgsProject.instance().title()

            if not self.title:
                self.data_projekt.setText(project)

            else:
                self.data_projekt.setText(self.title)

        else:
            pass

    def new_Project(self):

        '''Emptys data_projekt if a entirely new project is started'''

        if self.authToken:
            self.data_projekt.setText(qgis.core.QgsProject.instance().baseName())

        else:
            pass

    def button_add_Project(self):

        #pb
        # self.pB = progressBar()
        #self.pB.show()

        '''Function to add or change projects to the directory'''

        self.title = self.data_projekt.text()
        self.title = as_uid(self.title)
        self.data_projekt.setText(self.title)

        if self.title:
            self.rowPosition = self.table_proj.rowCount()
            qgis.core.QgsProject.instance().setTitle(self.title)
            items = []

            for row in range(self.rowPosition):
                item = self.table_proj.item(row, 0)
                item_text = item.text()
                items.append(item_text)

            if self.title in items:
                reply = qgis.PyQt.QtWidgets.QMessageBox.question(self.iface.mainWindow(),
                                            self.tr('Fortfahren?'),
                                            self.tr('Ein Projekt mit diesem Titel existiert bereits, soll dies ersetzt werden?'),
                                            qgis.PyQt.QtWidgets.QMessageBox.Yes,
                                            qgis.PyQt.QtWidgets.QMessageBox.No)

                if reply == QtWidgets.QMessageBox.Yes:
                    self.add_Project()
                    test = self.table_proj.findItems(self.title, qgis.PyQt.QtCore.Qt.MatchExactly)
                    self.table_proj.removeRow(test[0].row())

                else:
                    pass

            else:
                self.add_Project()

        else:
            self.iface.messageBar().pushCritical(self.tr('Kein Titel'),
                                                self.tr('Bitte geben Sie einen Titel für das Projekt an!'))

    def get_row(self):

        '''get the marked project from the table_proj'''

        try:
            self.row = self.table_proj.currentRow()
            self.projekt = self.table_proj.item(self.row, 0).text()

        except:
            pass

    def delete_Project(self):

        '''Function to delete (or move to trash) projects'''

        if self.projekt:
            perm = QtWidgets.QMessageBox
            ret = perm.question(self,
                                self.tr('Projekt löschen'),
                                self.tr('Soll das Projekt "')+ self.projekt + self.tr('" wirklich gelöscht werden?'),
                                perm.Yes | perm.No)

            if ret == perm.Yes:
                try:
                    answ = gws_api_call(self.hostname,
                                        'fsList',
                                        {},
                                        self.auth)

                    for key, value in answ.items():
                        for values in value:
                            for keys, valuess in values.items():
                                if str( self.projekt + '/') in valuess:
                                    answw = gws_api_call(self.hostname,
                                                        'fsDelete',
                                                        {'path': valuess},
                                                        self.auth)

                                elif str( self.projekt + '.config.cx') in valuess:
                                    answw = gws_api_call(self.hostname,
                                                        'fsDelete',
                                                        {'path': valuess},
                                                        self.auth)

                    self.table_proj.removeRow(self.row)
                    self.projekt = None
                    self.iface.messageBar().pushSuccess(self.tr('Erfolgreich gelöscht!'),
                                                        self.tr('Ihr Projekt wurde in den Papierkorb verschoben.'))

                except:
                    self.iface.messageBar().pushCritical(self.tr('Löschen fehlgeschlagen!'),
                                                        self.tr('Ihr Projekt ')
                                                        + self.projekt
                                                        + self.tr(' konnte nicht gelöscht werden.'))

            if ret == perm.No:
                pass

        else:
            self.iface.messageBar().pushCritical(self.tr('Keine Auswahl'),
                                                self.tr('Bitte wählen Sie ein Projekt aus das sie löschen möchten.'))

    def load_Project(self):

        '''Load projects from the Websuite folder'''

        #if self.td:
        #    shutil.rmtree(self.td)

        #else:
        #    pass

        if self.projekt:

            pathlib.Path(self.projectFolder, self.projekt).mkdir(parents=True, exist_ok=True)

            if os.path.isfile(os.path.join(self.projectFolder, self.projekt, 'hash_list.json')):
                serverHashList = self.H.load_hash_list(self.hostname, self.auth, self.projekt)
                print('Server: ',serverHashList)

                with open (os.path.join(self.projectFolder, self.projekt, 'hash_list.json')) as fp:
                    localHashList = json.load(fp)
                    print('local: ',localHashList)

                downloadLayer = []

                try:
                    for key in serverHashList.keys():
                        if key in localHashList.keys():
                            if serverHashList[key][0] == localHashList[key][0]:
                                pass
                            else:
                                '''layer downloaden?!'''
                                downloadLayer.append(serverHashList[key][1])

                        else:
                            '''layer downloaden!'''
                            downloadLayer.append(serverHashList[key][1])

                    answ = gws_api_call(self.hostname,
                                        'fsList',
                                        {},
                                        self.auth)

                    print(answ)

                    for key, value in answ.items():
                        for values in value:
                            for keys, valuess in values.items():
                                if valuess.startswith(str(self.projekt + '/')):
                                    if valuess.endswith('.qgs'):
                                        op_proj = gws_api_call(self.hostname, 'fsRead', {'path': valuess}, self.auth)
                                        #self.path = os.path.join(self.td, self.projekt + '.qgs')
                                        self.path = os.path.join(self.projectFolder, self.projekt, self.projekt + '.qgs')
                                        with open(self.path, 'w') as save_proj:
                                            #save_proj = open(self.path, 'w')
                                            op_proj = op_proj['data'].decode('utf-8')
                                            save_proj.write(op_proj)

                                    elif valuess.endswith('.json'):
                                        op_hash = gws_api_call(self.hostname, 'fsRead', {'path': valuess}, self.auth)
                                        pathH = os.path.join(self.projectFolder, self.projekt, valuess.split('/')[1])
                                        with open(pathH, 'w') as save_hash:
                                            #save_hash = open(pathH, 'w')
                                            op_hash = op_hash['data'].decode('utf-8')
                                            save_hash.write(op_hash)

                                    else:
                                        for downlay in downloadLayer:
                                            if valuess in downlay:
                                                op_layer = gws_api_call(self.hostname,
                                                                        'fsRead',
                                                                        {'path': valuess},
                                                                        self.auth)
                                                #pathh = os.path.join(self.td, valuess.split('/')[1])
                                                pathh = os.path.join(self.projectFolder, self.projekt, valuess.split('/')[1])
                                                with open(pathh, 'w') as save_layer:
                                                    #save_layer = open(pathh, 'w')
                                                    op_layer = op_layer['data'].decode('utf-8')
                                                    save_layer.write(op_layer)
                                            else:
                                                pass

                                else:
                                    pass

                except NameError:
                    '''hier wird alles heruntergeladen?!'''

                    answ = gws_api_call(self.hostname,
                                    'fsList',
                                    {},
                                    self.auth)

                    print(answ)

                    for key, value in answ.items():
                        for values in value:
                            for keys, valuess in values.items():
                                if valuess.startswith(str(self.projekt + '/')):
                                    if valuess.endswith('.qgs'):
                                        op_proj = gws_api_call(self.hostname, 'fsRead', {'path': valuess}, self.auth)
                                        #self.path = os.path.join(self.td, self.projekt + '.qgs')
                                        self.path = os.path.join(self.projectFolder, self.projekt, self.projekt + '.qgs')
                                        with open(self.path, 'w') as save_proj:
                                            #save_proj = open(self.path, 'w')
                                            op_proj = op_proj['data'].decode('utf-8')
                                            save_proj.write(op_proj)

                                    elif valuess.endswith('.json'):
                                        op_hash = gws_api_call(self.hostname, 'fsRead', {'path': valuess}, self.auth)
                                        pathH = os.path.join(self.projectFolder, self.projekt, valuess.split('/')[1])
                                        with open(pathH, 'w') as save_hash:
                                            #save_hash = open(pathH, 'w')
                                            op_hash = op_hash['data'].decode('utf-8')
                                            save_hash.write(op_hash)

                                    else:
                                        op_layer = gws_api_call(self.hostname,
                                                                'fsRead',
                                                                {'path': valuess},
                                                                self.auth)
                                        #pathh = os.path.join(self.td, valuess.split('/')[1])
                                        pathh = os.path.join(self.projectFolder, self.projekt, valuess.split('/')[1])
                                        with open(pathh, 'w') as save_layer:
                                            #save_layer = open(pathh, 'w')
                                            op_layer = op_layer['data'].decode('utf-8')
                                            save_layer.write(op_layer)

                                else:
                                    pass


            else:

                answ = gws_api_call(self.hostname,
                                    'fsList',
                                    {},
                                    self.auth)

                print(answ)

                for key, value in answ.items():
                    for values in value:
                        for keys, valuess in values.items():
                            if valuess.startswith(str(self.projekt + '/')):
                                if valuess.endswith('.qgs'):
                                    op_proj = gws_api_call(self.hostname, 'fsRead', {'path': valuess}, self.auth)
                                    #self.path = os.path.join(self.td, self.projekt + '.qgs')
                                    self.path = os.path.join(self.projectFolder, self.projekt, self.projekt + '.qgs')
                                    with open(self.path, 'w') as save_proj:
                                        #save_proj = open(self.path, 'w')
                                        op_proj = op_proj['data'].decode('utf-8')
                                        save_proj.write(op_proj)

                                elif valuess.endswith('.json'):
                                    op_hash = gws_api_call(self.hostname, 'fsRead', {'path': valuess}, self.auth)
                                    pathH = os.path.join(self.projectFolder, self.projekt, valuess.split('/')[1])
                                    with open(pathH, 'w') as save_hash:
                                        #save_hash = open(pathH, 'w')
                                        op_hash = op_hash['data'].decode('utf-8')
                                        save_hash.write(op_hash)

                                else:
                                    op_layer = gws_api_call(self.hostname,
                                                            'fsRead',
                                                            {'path': valuess},
                                                            self.auth)
                                    #pathh = os.path.join(self.td, valuess.split('/')[1])
                                    pathh = os.path.join(self.projectFolder, self.projekt, valuess.split('/')[1])
                                    with open(pathh, 'w') as save_layer:
                                        #save_layer = open(pathh, 'w')
                                        op_layer = op_layer['data'].decode('utf-8')
                                        save_layer.write(op_layer)

                            else:
                                pass

        else:
            self.iface.messageBar().pushCritical(self.tr('Laden fehlgeschlagen'),
                                                self.tr('Bitte wählen Sie ein Projekt aus!'))

    def open_Help(self):

        '''Open the Link to GWS-Website / Help'''

        webbrowser.open('https://gws.gbd-consult.de/', new = 0, autoraise = True)

    def clear_Plugin(self):

        '''emptys the Plugin'''

        self.authToken = False
        self.table_proj.setRowCount(0)
        self.data_projekt.setText('')
        self.label_5.setText(self.tr("Angemeldet als: "))
        self.aktuelles_projekt.setEnabled(False)
        self.liste_projekte.setEnabled(False)
        self.table_proj.setEnabled(False)
        '''if self.td:
            shutil.rmtree(self.td)
            self.td = None

        else:
            pass'''

    def closeEvent(self, event):

        '''what happens if the plugin is closed'''


        self.clear_Plugin()
        self.closingPlugin.emit()
        event.accept()

    def open_Project(self):

        '''
        Just to open the Project, and to avoid, 
        that the project is read before the last layer is proper downloaded
        '''

        qgis.core.QgsProject.instance().read(self.path)

    def checkServer(self, max_tries = 0):
        while max_tries < 30:
            max_tries += 1
            a1 = r.get(self.hostname + 'project/' + self.title)
            if a1.status_code != 200:
                time.sleep(1)
            else:
                self.table_proj.insertRow(self.rowPosition)
                self.table_proj.setItem(self.rowPosition, 0, QtWidgets.QTableWidgetItem(self.title))
                self.table_proj.setCellWidget(self.rowPosition, 1, EditButtonWidget(self.rowPosition, self.title, self.hostname, self.font))
                self.table_proj.scrollToItem(self.table_proj.item(self.rowPosition, 0))
                self.table_proj.setCurrentCell(self.rowPosition, 0)
                self.iface.messageBar().pushSuccess(self.tr('Projekt gespeichert'),
                                                    self.tr('Sie können es jetzt unter "')
                                                    + str(self.hostname
                                                    + 'project/'
                                                    + self.title)
                                                    + self.tr('" abrufen.'))
                '''self.iface.mainWindow().statusBar().clearMessage()'''
                break
        else:
            self.iface.messageBar().pushCritical(self.tr('GWS Fehler'),
                                                    self.tr('Server konnte noch nicht gestartet werden. Bei erneutem auftreten kontaktieren Sie bitte Ihren Admin.'))

    def add_Project(self):

        '''
        Function to add a new Project to the Server
        '''
        #pb
        #self.countChanged.emit(5)

        if qgis.core.QgsProject.instance().crs().authid()[:4] == 'EPSG':
            if qgis.core.QgsProject.instance().crs().mapUnits() == 0:

                QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)

                proj_crs = qgis.core.QgsProject.instance().crs().authid()

                if proj_crs != 'EPSG:3857':
                    inProj = pyproj.Proj(init='epsg:3857')
                    outProj = pyproj.Proj(init=proj_crs)

                    x1, y1= (644000, 5980000)
                    x3, y3 = pyproj.transform(inProj, outProj, x1, y1)
                    x2, y2 = (1680000, 7390000)
                    x4, y4 = pyproj.transform(inProj, outProj, x2, y2)

                    extentGermany = []
                    extentGermany.append(x3)
                    extentGermany.append(y3)
                    extentGermany.append(x4)
                    extentGermany.append(y4)

                    extentGermany = str(extentGermany)
                    extentGermany = extentGermany.replace(',', '')
                    
                else:
                    extentGermany = [644000, 5980000, 1680000, 7390000]
                    extentGermany = str(extentGermany)
                    extentGermany = extentGermany.replace(',', '')

                #proj_dir = tempfile.mkdtemp()
                pathlib.Path(self.projectFolder, self.title).mkdir(parents=True, exist_ok=True)
                proj_dir = os.path.join(self.projectFolder, self.title)

                hashListServer = self.H.load_hash_list(self.hostname, self.auth, self.title)
                print("hier :", hashListServer)

                change_layer_source = []
                changeMemoryLayers = []
                excludeLayers = []
                tileLayers = {}
                hashList = {}

                #pb
                # self.countChanged.emit(15)

                for layer in qgis.core.QgsProject.instance().mapLayers().values():
                    if layer.providerType() in {'ogr', 'memory'}:
                        '''self.iface.mainWindow().statusBar().showMessage("Bereite Layer "
                                                                        + layer.name()
                                                                        + " vor.")'''

                        file_path = os.path.join(proj_dir, layer.name() + '.geojson')
                        #file_path = os.path.join(proj_dir, layer.id() + '.geojson')

                        """qgis.core.QgsVectorFileWriter.writeAsVectorFormat(layer, 
                                                                            os.path.join(proj_dir,
                                                                                        layer.name()
                                                                                        + '.geojson'),
                                                                            'utf-8',
                                                                            driverName = 'GeoJson')"""
                        qgis.core.QgsVectorFileWriter.writeAsVectorFormat(layer, 
                                                                            file_path,
                                                                            'utf-8',
                                                                            driverName = 'GeoJson')

                        """lay_stor = os.path.getsize(os.path.join(proj_dir,
                                                                layer.name() 
                                                                + '.geojson'))"""
                        #lay_stor = os.path.getsize(file_path)
                        
                        #if lay_stor < 20 000 000:
                        #if lay_star < 1000000000:
                        change_layer_source.append(layer.id())
                        
                        #pb
                        #self.uLE = uploadLayersExternal(proj_dir, layer.name(), self.hostname, self.title, self.auth)
                        #self.uLE.countChanged.connect(self.onCountChanged)
                        #self.uLE.start()
                        #self.uLE.run(proj_dir, layer.name(), self.hostname, self.title, self.auth)
                        #self.countChanged.emit(25)

                        #buildHash = gbd_manager_hash.build_hash(path=file_path)
                        #hashList[layer.id()] = buildHash

                        with open(os.path.join(proj_dir, layer.name() + '.geojson'), 'rb') as fp:
                        #with open(os.path.join(proj_dir, layer.id() + '.geojson'), 'rb') as fp:
                            data = fp.read()

                            buildHash, hashStatus = self.H.build_hash(data, hashListServer, layer.id())
                            print('buildHash: ',buildHash)
                            print('hashStatus: ',hashStatus)

                            if hashStatus is not None:
                                print('layer neu gesendet')
                                answ = gws_api_call(
                                    self.hostname,
                                    'fsWrite',
                                    {'path': '/'
                                    + self.title
                                    + '/'
                                    + layer.name()
                                    #+ layer.id()
                                    + '.geojson',
                                    'data': data},
                                    auth = self.auth )

                                hashList[layer.id()] = (buildHash, layer.name())

                            else:
                                print('layer passt wie er ist')
                                hashList[layer.id()] = (buildHash, layer.name())

                            #pb
                            # self.countChanged.emit(75)

                            if layer.providerType() == 'memory':
                                changeMemoryLayers.append(layer.id())

                        '''else:
                            excludeLayers.append(layer.name())
                            self.iface.messageBar().pushCritical(self.tr('Layer nicht hinzugefügt'),
                                                                layer.name()
                                                                + self.tr(' ist größer als 25 MB.'))'''

                    elif layer.providerType() == 'gdal':
                        excludeLayers.append(layer.name())
                        self.iface.messageBar().pushWarning(self.tr('Raster Layer'),
                                                            self.tr('Ihr Layer "')
                                                            + layer.name()
                                                            + self.tr('" wird nicht angezeigt, da es sich um einen Raster-Layer handelt.'))

                    elif layer.providerType() == 'wms':
                        if 'type=xyz' in layer.publicSource():
                            htmlText = layer.htmlMetadata()
                            url = htmlText.split('<td>GetCapabilitiesUrl</td><td>', 1)[1].split('</td>', 1)[0]
                            tileLayers[layer.name()] = url
                    else:
                        pass
                
                self.H.save_hash_list(self.hostname, self.auth, self.title, hashList, proj_dir)

                '''self.iface.mainWindow().statusBar().showMessage("Erstelle die Konfiguration.")'''
                qgis.core.QgsProject.instance().write(os.path.join(proj_dir, self.title + '.qgs'))
                tree = ET.parse(str(os.path.join(proj_dir, self.title + '.qgs')))
                root = tree.getroot()

                for maplayer in root.iter('maplayer'):
                    id = maplayer.find('id')
                    if id.text in change_layer_source:
                        datasource = maplayer.find('datasource')
                        name = maplayer.find('layername')
                        datasource.text = './' + name.text + '.geojson'
                        #datasource.text = './' + id.text + '.geojson'

                    if id.text in changeMemoryLayers:
                        pe = maplayer.find('provider')
                        pe.attrib['encoding'] = 'UTF-8'
                        pe.text = 'ogr'

                    else:
                        pass

                for templayer in root.iter('layer-tree-layer'):
                    id = templayer.attrib['id']
                    #if id in change_layer_source:
                        #templayer.attrib['source'] = './' + id + '.geojson'
                    if id in changeMemoryLayers:
                        templayer.attrib['providerKey'] = 'ogr'

                tree.write(str(os.path.join(proj_dir, self.title + '.qgs')))

                with open(str(os.path.join(proj_dir, self.title + '.qgs')), 'rb') as fp:
                    data = fp.read()

                gws_api_call(
                    self.hostname, 
                    'fsWrite', 
                    {'path': '/' + self.title + '/' + self.title + '.qgs', 'data': data},
                    auth = self.auth
                )

                center = self.iface.mapCanvas().extent().center().toString()
                center = center.replace(",", " ")

                init_scale = str(self.iface.mapCanvas().scale())

                config = """ 
                    {
                        title """ + self.title + """
                        map.crs """ + '"' + proj_crs + '"' + """
                        map.center [""" + center + """]
                        map.zoom.initScale """ + init_scale + """
                        map.zoom.scales [1000000 500000 250000 150000 70000 50000 25000 10000 5000 2500 1000 500 250]
                        map.extentBuffer {{5000}}   
                        map.extent """ + extentGermany + """

                        api.actions+ { type "search"}

                        map.layers+  {
                            title """ + self.title + """
                            type "qgis" 
                            path "./""" + self.title + """/""" + self.title + """.qgs"
                            directRender ["wms"]
                        }
                    }"""

                #Dynamic Parts of the config.cx

                if excludeLayers:
                    pos = config.find('.qgs') + 5
                    config2 = config[:pos] + """
                    excludeLayers:
                        \t{"names": """ + str(excludeLayers) + """
                    }""" + config[pos:]
                    config = config2
                else:
                    pass


                if not tileLayers:
                    pass
                else:
                    for i in tileLayers:
                        config3 = config[:-1] + """map.layers+  {
                            title """ + '''"''' + i + '''"''' + """
                            type "tile"
                            url """ + '''"''' + tileLayers[i] + '''"''' +""" \n}
                            """ + config[-1:]
                        config = config3

                ###

                gws_api_call(
                    self.hostname,
                    'fsWrite',
                    {'path': self.title + '.config.cx', 'data': config},
                    auth = self.auth
                )

                self.checkServer()

                #pb
                # self.countChanged.emit(100)

                QtWidgets.QApplication.restoreOverrideCursor()

            else:
                self.iface.messageBar().pushCritical(self.tr('CRS Fehler!'), self.tr('Bitte wählen Sie ein Koordinatensystem aus, das auf Meter als Einheit nutzt.'))
        
        else:
            self.ifac.messageBar().pushCritical(self.tr('CRS Fehler!'), self.tr('Bitte wählen sie ein EPSG-Koordinatensystem aus.'))

'''class uploadLayersExternal(QThread):

    countChanged = pyqtSignal(int)

    def __init__(self, proj_dir, layer, hostname, title, auth):
        QThread.__init__(self)

    def run(self):

        self.proj_dir = proj_dir
        self.layer = layer
        self.hostname = hostname
        self.title = title
        self.auth = auth

        with open(os.path.join(self.proj_dir, self.layer + '.geojson'), 'rb') as fp:
                                data = fp.read()
                                answ = gws_api_call(
                                    self.hostname,
                                    'fsWrite',
                                    {'path': '/'
                                    + self.title
                                    + '/'
                                    + self.layer
                                    + '.geojson',
                                    'data': data},
                                    auth = self.auth )
        self.countChanged.emit(10)

class External(QThread):
    """
    Runs a counter thread.
    """

    countChanged = pyqtSignal(int)

    def run(self, TIME_LIMIT=100):
        count = 0
        while count < TIME_LIMIT:
            count +=1
            time.sleep(1)
            self.countChanged.emit(count)'''


class EditButtonWidget(QtWidgets.QWidget):

    '''
    Class that builds the Buttons in the "aktuelle Projekte" List
    '''
    
    def __init__(self, row, title, host, font, parent=None):
        super(EditButtonWidget,self).__init__(parent)

        # variables 
        self.title = title
        self.row = row
        self.font = font
        self.hostname = host

        ###Layout###

        self.layout = QtWidgets.QHBoxLayout(self)

        self.layout.setContentsMargins(0,0,0,0)
        self.layout.setSpacing(0)

        self.b1 = QtWidgets.QPushButton()
        self.b1.setToolTip(self.tr('Öffne die WebSuite'))
        self.b1.setIcon(QtGui.QIcon(':/plugins/gbd_websuite_plugin/icons/icon.png'))
        self.b1.clicked.connect(self.doButtonB1)

        self.b2 = QtWidgets.QPushButton()
        self.b2.setToolTip(self.tr('Link anzeigen'))
        self.b2.setIcon(QtGui.QIcon(':/plugins/gbd_websuite_plugin/icons/link.png'))
        self.b2.clicked.connect(self.doButtonB2)

        self.layout.addWidget(self.b1)
        self.layout.addWidget(self.b2)

        self.setLayout(self.layout)

    def doButtonB1(self):

        '''Opens the Link to the weblink and the GBD WebSuite'''

        webbrowser.open( self.hostname 
                        + str('project/')
                        + self.title, 
                        new = 0, 
                        autoraise = True)
        
    def doButtonB2(self):

        '''Opens a QT-Window that shows the Link and allows it to copy it'''

        clipboard = qgis.PyQt.QtWidgets.QApplication.clipboard().setText(self.title)
        
        self.w = Window2(self.title, self.hostname, self.font)
        self.w.show()
       
class Window2(QtWidgets.QMainWindow):

    '''
    Class that builds the MainWindow to show the Links to the different WebMaps
    '''
    def __init__(self, title, host, font):
        super().__init__()

        # variables
        self.title = title
        self.font = font
        self.hostname = host

        # Layout
        self.setGeometry(0,0,670,185)
        self.setWindowTitle(self.tr('Link zum Projekt: ') + self.title)

        self.pushButton = QtWidgets.QPushButton(self)
        self.pushButton.setGeometry(qgis.PyQt.QtCore.QRect(540, 20, 110, 25))
        self.pushButton.setObjectName("pushButton")
        self.pushButton.setText(self.tr("Link kopieren"))
        self.pushButton.clicked.connect(self.copy_link)
        self.pushButton.setFont(self.font)

        self.pushButton_2 = QtWidgets.QPushButton(self)
        self.pushButton_2.setGeometry(qgis.PyQt.QtCore.QRect(540, 80, 110, 25))
        self.pushButton_2.setObjectName("pushButton_2")
        self.pushButton_2.setText(self.tr("Link kopieren"))
        self.pushButton_2.setFont(self.font)

        self.pushButton_3 = QtWidgets.QPushButton(self)
        self.pushButton_3.setGeometry(qgis.PyQt.QtCore.QRect(540, 140, 110, 25))
        self.pushButton_3.setObjectName("pushButton_3")
        self.pushButton_3.setText(self.tr("Link kopieren"))
        self.pushButton_3.setFont(self.font)

        self.label = QtWidgets.QLabel(self)
        self.label.setGeometry(qgis.PyQt.QtCore.QRect(20, 20, 67, 17))
        self.label.setObjectName("label")
        self.label.setText(self.tr("Webseite: "))
        self.label.setFont(self.font)

        self.label_2 = QtWidgets.QLabel(self)
        self.label_2.setGeometry(qgis.PyQt.QtCore.QRect(20, 80, 67, 17))
        self.label_2.setObjectName("label_2")
        self.label_2.setText(self.tr("WMS: "))
        self.label_2.setFont(self.font)

        self.label_3 = QtWidgets.QLabel(self)
        self.label_3.setGeometry(qgis.PyQt.QtCore.QRect(20, 140, 67, 17))
        self.label_3.setObjectName("label_3")
        self.label_3.setText(self.tr("WFS: "))
        self.label_3.setFont(self.font)

        self.textBrowser = QtWidgets.QTextBrowser(self)
        self.textBrowser.setEnabled(True)
        self.textBrowser.setGeometry(qgis.PyQt.QtCore.QRect(90, 20, 450, 25))
        self.textBrowser.setOpenExternalLinks(True)
        self.textBrowser.setObjectName("textBrowser")
        self.textBrowser.setText(self.hostname + str('project/' + self.title))

        self.textBrowser_2 = QtWidgets.QTextBrowser(self)
        self.textBrowser_2.setGeometry(qgis.PyQt.QtCore.QRect(90, 80, 450, 25))
        self.textBrowser_2.setObjectName("textBrowser_2")
        self.textBrowser_2.setText(self.hostname + str('project/'))

        self.textBrowser_3 = QtWidgets.QTextBrowser(self)
        self.textBrowser_3.setGeometry(qgis.PyQt.QtCore.QRect(90, 140, 450, 25))
        self.textBrowser_3.setObjectName("textBrowser_3")
        self.textBrowser_3.setText(self.hostname + str('project/'))
        
        self.center()

    def center(self):

        '''
        Center the Mainwindow in the active Screen
        https://stackoverflow.com/questions/20243637/pyqt4-center-window-on-active-screen
        '''
        
        frameGm = self.frameGeometry()
        screen = QtWidgets.QApplication.desktop().screenNumber(QtWidgets.QApplication.desktop().cursor().pos())
        centerPoint = QtWidgets.QApplication.desktop().screenGeometry(screen).center()
        frameGm.moveCenter(centerPoint)
        self.move(frameGm.topLeft())
      
    def copy_link(self):

        qgis.PyQt.QtWidgets.QApplication.clipboard().setText(self.hostname + str('project/') + self.title)